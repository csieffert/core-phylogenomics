#!/usr/bin/env perl

package Stage::RearrangeSNPMatrix;

use Stage;
use Bio::Phylo::IO;
use Bio::Phylo::Forest::Tree;
use Text::CSV;
@ISA = qw(Stage);

use strict;
use warnings;

sub new
{
        my ($proto, $job_properties, $logger) = @_;
        my $class = ref($proto) || $proto;
        my $self = $class->SUPER::new($job_properties, $logger);
        bless($self,$class);

	$self->{'_stage_name'} = 'rearrange-snp-matrix';

        return $self; 
}

#Submodule to re-root the phylogenetic tree with the indicated strain.
#Input: 
#	$input_taxa_tree -> The phylogenetic tree to re-root
#   $newRootStrain -> The strain to root 
sub reRootTree
{
	my ($self, $input_taxa_tree, $newRootStrain) = @_;
	my $logger = $self->{'_logger'};
	my $newRoot = "'".$newRootStrain."'";
	foreach my $node ( @{ $input_taxa_tree->get_entities } ){ 
       if($node->get_name() eq $newRoot)
       {
          $input_taxa_tree->deroot();
          $node->set_root_below();
		  $logger->log("The phylogenetic tree has been successfully re-rooted on strain: ".$node->get_name()."\n", 0);
		  return;	
       }
    }
    $logger->log("The requested strain".$newRoot."could not be found in the phylogenetic tree.\n", 0);
}

#submodule to rearrange the entries in matrix.csv to match the new phylogenetic ordering
sub updateMatrixCsv
{
	my ($self, $input_taxa_tree) = @_;
	#open a new file handle to print the output to
	open(my $revisedMatrixCsv, '>revisedMatrix.csv') or die "Could not open the output file: $!";
	
	#open file handle for input matrix.csv file
	my $inputMatrixFile = $self->{'_job_properties'}->get_property('inputMatrix');
	open(my $data, '<', $inputMatrixFile) or die "Could not open '$inputMatrixFile' $!\n";
	
	my $csv = Text::CSV->new({ sep_char => '\t' });
	#hash the two-dimensional matrix as 'keyColumn:keyRow' : 'value' pairs to facilitate rearrangement 
	my %matrixHash = ();
	my @strainColumn=[];
	#parse the input matrix and retain the first row for strain names in @strainNames
	while (my $input = <$data>) {
		my @line = split(/\t/, $input);
		#add all of the strain names for each row
		if($line[0] eq 'strain'){
			@strainColumn = split(/ /, "@line");
		}
		else{
			my $strainRow = $line[0];
			my $index = 0;
			#hash the values in the matrix as 'keyColumn:keyRow' : 'value'
			foreach(@line){
				$matrixHash{"'".$strainColumn[$index]."'".':'."'".$strainRow."'"} = $_; 
				$index++; 
			}	
		}
	}
			
	#using reference tree, rearrange and output a new matrix.csv file
	print $revisedMatrixCsv "strain\t";
	foreach(@{ $input_taxa_tree->get_entities }){
		if($_->is_terminal()){
			print $revisedMatrixCsv $_->get_name()."\t";
		}
	}
	print $revisedMatrixCsv "\n";
	foreach( @{ $input_taxa_tree->get_entities } ) {
		if($_->is_terminal()){
    		my $rowNode = $_->get_name();
    		print $revisedMatrixCsv $_->get_name()."\t";
    		foreach( @{ $input_taxa_tree->get_entities } ) {
    			if($_->is_terminal()){
    				my $hashQuery = $rowNode.':'.$_->get_name();
    				my $hashResult = $matrixHash{$hashQuery};
    				print $revisedMatrixCsv $hashResult."\t";
    			}
    		}
    		print $revisedMatrixCsv "\n";	      
		}
    }
	close($revisedMatrixCsv);
	close($data); 
}

sub branchLengthToSNP
{
	my ($self, $input_taxa_tree) = @_;
		
}

sub execute
{	
	my ($self) = @_;
	my $logger = $self->{'_logger'};
	my $stage = $self->get_stage_name;
	
	my $job_properties = $self->{'_job_properties'};
	my $taxa_file = $job_properties->get_property('input_taxa_dir');
	$taxa_file .= '/pseudoalign.phy_phyml_tree.txt';
	my $taxa ={};
	bless($taxa, "Bio::Phylo::Forest::Tree");
		
	#parse the newick format phylogeny generated by phyml into a Bio::Phylo::Forest::Tree object
	$taxa = Bio::Phylo::IO->parse(
    	'-file'   => $taxa_file,
    	'-format'   => 'newick'
 	)->first;
 	
 	#reroot the tree if requested by user:
 	$self->reRootTree($taxa, $job_properties->get_property('root_strain')) if defined $job_properties->get_property('root_strain');
 	
 	#determine whether the tree should be re-sorted in decreasing or increasing order
 	if($job_properties->get_property('tree_order') eq "decreasing"){
 		$taxa->ladderize();
 	}
 	elsif($job_properties->get_property('tree_order') eq "increasing"){
 		$taxa->ladderize(1);
 	}
 	
 	#print the new phylogenetic tree to the output file.
 	open(my $taxaout, '>phylogeneticTree.txt') or die "Could not open output file: $!";
 	print $taxaout $taxa->to_newick( -header => 1, -links => 1 );
 	$self->updateMatrixCsv($taxa);
 	close($taxaout);
}



